const std = @import("std");

const Context = @import("./root.zig").Context;

pub fn solve(ctx: Context) !void {
    const boxes = try parseBoxes(ctx.alloc, ctx.input);
    const part1 = try solvePart1(ctx.alloc, boxes, 1000);
    try ctx.writer.print(
        \\part1: {d}
        \\part2: {d}
        \\
    , .{ part1, 0 });
}

fn parseBoxes(alloc: std.mem.Allocator, src: []const u8) ![]Coord {
    var boxes: std.ArrayList(Coord) = .empty;
    errdefer boxes.deinit(alloc);
    var it = std.mem.splitScalar(u8, src, '\n');
    while (it.next()) |line| {
        if (line.len == 0) break;
        const box = try Coord.parse(line);
        try boxes.append(alloc, box);
    }
    return try boxes.toOwnedSlice(alloc);
}

fn solvePart1(alloc: std.mem.Allocator, boxes: []Coord, comptime num_connections: u32) !u32 {
    var dists: std.ArrayList(Key) = try .initCapacity(alloc, num_connections);
    defer dists.deinit(alloc);

    for (0.., boxes) |index_a, box_a| {
        for (index_a + 1.., boxes[index_a + 1 ..]) |index_b, box_b| {
            // if (index_a == index_b) continue;
            const dist = box_a.dist(box_b);
            try addTo(alloc, &dists, .{ .dist = dist, .index_a = index_a, .index_b = index_b });
            if (dists.items.len > num_connections) {
                dists.shrinkRetainingCapacity(num_connections);
            }
        }
    }

    var circuits: std.ArrayList(std.ArrayList(usize)) = .empty;
    defer {
        for (circuits.items) |*circuit| {
            circuit.deinit(alloc);
        }
        circuits.deinit(alloc);
    }
    blk: for (dists.items) |d| {
        std.debug.print("it\n", .{});
        for (circuits.items) |c| {
            std.debug.print("{any}\n", .{c.items});
        }
        for (circuits.items) |*circuit| {
            const contains_a = std.mem.indexOfScalar(usize, circuit.items, d.index_a) != null;
            const contains_b = std.mem.indexOfScalar(usize, circuit.items, d.index_b) != null;
            if (contains_a and contains_b) {
                // do nothing
            } else if (contains_a) {
                try circuit.append(alloc, d.index_b);
                continue :blk;
            } else if (contains_b) {
                try circuit.append(alloc, d.index_a);
                continue :blk;
            }
        }
        var circuit: std.ArrayList(usize) = .empty;
        try circuit.append(alloc, d.index_a);
        try circuit.append(alloc, d.index_b);
        try circuits.append(alloc, circuit);
    }

    std.mem.sort(std.ArrayList(usize), circuits.items, {}, struct {
        fn f(_: void, a: std.ArrayList(usize), b: std.ArrayList(usize)) bool {
            return a.items.len > b.items.len;
        }
    }.f);
    for (circuits.items) |c| {
        std.debug.print("{any}\n", .{c.items});
    }

    const a: u32 = @intCast(circuits.items[0].items.len);
    const b: u32 = @intCast(circuits.items[1].items.len);
    const c: u32 = @intCast(circuits.items[2].items.len);
    return a * b * c;
}

const Key = struct {
    dist: f32,
    index_a: usize,
    index_b: usize,
};

fn addTo(alloc: std.mem.Allocator, dists: *std.ArrayList(Key), key: Key) !void {
    for (0.., dists.items) |index, it| {
        if (it.dist > key.dist) {
            try dists.insert(alloc, index, key);
            return;
        }
    }
    if (dists.items.len < dists.capacity) {
        try dists.append(alloc, key);
    }
}

const Coord = struct {
    x: u32,
    y: u32,
    z: u32,

    fn parse(src: []const u8) !Coord {
        const x_str, const rest_x = cut(src, ',') orelse return error.InvalidInput;
        const x = try std.fmt.parseInt(u32, x_str, 10);
        const y_str, const z_str = cut(rest_x, ',') orelse return error.InvalidInput;
        const y = try std.fmt.parseInt(u32, y_str, 10);
        const z = try std.fmt.parseInt(u32, z_str, 10);
        return .{ .x = x, .y = y, .z = z };
    }

    fn dist(a: Coord, b: Coord) f32 {
        const dx = @as(i64, @intCast(a.x)) - @as(i64, @intCast(b.x));
        const dy = @as(i64, @intCast(a.y)) - @as(i64, @intCast(b.y));
        const dz = @as(i64, @intCast(a.z)) - @as(i64, @intCast(b.z));
        const sx = std.math.pow(f32, @floatFromInt(dx), 2);
        const sy = std.math.pow(f32, @floatFromInt(dy), 2);
        const sz = std.math.pow(f32, @floatFromInt(dz), 2);
        return std.math.sqrt(sx + sy + sz);
    }
};

fn cut(src: []const u8, at: u8) ?struct { []const u8, []const u8 } {
    const index = std.mem.indexOfScalar(u8, src, at) orelse return null;
    return .{ src[0..index], src[index + 1 ..] };
}

test "example part 1" {
    const input =
        \\162,817,812
        \\57,618,57
        \\906,360,560
        \\592,479,940
        \\352,342,300
        \\466,668,158
        \\542,29,236
        \\431,825,988
        \\739,650,466
        \\52,470,668
        \\216,146,977
        \\819,987,18
        \\117,168,530
        \\805,96,715
        \\346,949,466
        \\970,615,88
        \\941,993,340
        \\862,61,35
        \\984,92,344
        \\425,690,689
        \\
    ;
    const boxes = try parseBoxes(std.testing.allocator, input);
    defer std.testing.allocator.free(boxes);

    try std.testing.expectEqual(40, try solvePart1(std.testing.allocator, boxes, 10));
}
